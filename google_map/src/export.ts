import PDFDocument from 'pdfkit';
import { Document, Paragraph, TextRun, HeadingLevel, Packer } from 'docx';
import { ChatMessage } from './agent';

// Export chat history as plain text
export function exportAsText(messages: ChatMessage[]): string {
  const lines: string[] = [
    'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•',
    '                    GOOGLE MAPS AGENT CHAT LOG                  ',
    'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•',
    `Exported: ${new Date().toLocaleString()}`,
    `Total Messages: ${messages.length}`,
    'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•',
    '',
  ];

  for (const msg of messages) {
    const timestamp = new Date(msg.timestamp).toLocaleString();
    const role = msg.role.toUpperCase();
    
    lines.push('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    lines.push(`[${timestamp}] ${role}:`);
    lines.push('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    lines.push(msg.content);
    
    if (msg.toolCalls && msg.toolCalls.length > 0) {
      lines.push('');
      lines.push('ğŸ“ Tool Calls:');
      for (const tool of msg.toolCalls) {
        lines.push(`  â€¢ ${tool.toolName}`);
        lines.push(`    Input: ${JSON.stringify(tool.input)}`);
      }
    }
    lines.push('');
  }

  lines.push('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  lines.push('                         END OF LOG                            ');
  lines.push('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

  return lines.join('\n');
}

// Export chat history as PDF
export async function exportAsPDF(messages: ChatMessage[]): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];
    
    const doc = new PDFDocument({
      margin: 50,
      size: 'A4',
    });

    doc.on('data', (chunk) => chunks.push(chunk));
    doc.on('end', () => resolve(Buffer.concat(chunks)));
    doc.on('error', reject);

    // Header
    doc.fontSize(20).font('Helvetica-Bold').text('Google Maps Agent', { align: 'center' });
    doc.fontSize(12).font('Helvetica').text('Chat Export', { align: 'center' });
    doc.moveDown(0.5);
    doc.fontSize(10).text(`Exported: ${new Date().toLocaleString()}`, { align: 'center' });
    doc.text(`Total Messages: ${messages.length}`, { align: 'center' });
    doc.moveDown();
    
    // Divider
    doc.strokeColor('#cccccc').lineWidth(1)
      .moveTo(50, doc.y).lineTo(545, doc.y).stroke();
    doc.moveDown();

    // Messages
    for (const msg of messages) {
      const timestamp = new Date(msg.timestamp).toLocaleString();
      const isUser = msg.role === 'user';
      
      // Role header with color
      doc.fillColor(isUser ? '#2563eb' : '#059669')
        .fontSize(11).font('Helvetica-Bold')
        .text(`${msg.role.toUpperCase()}`, { continued: true });
      
      doc.fillColor('#666666').fontSize(9).font('Helvetica')
        .text(`  ${timestamp}`);
      
      doc.moveDown(0.3);
      
      // Message content
      doc.fillColor('#333333').fontSize(10).font('Helvetica')
        .text(msg.content, { lineGap: 3 });

      // Tool calls
      if (msg.toolCalls && msg.toolCalls.length > 0) {
        doc.moveDown(0.3);
        doc.fillColor('#8b5cf6').fontSize(9).font('Helvetica-Bold')
          .text('Tool Calls:');
        
        for (const tool of msg.toolCalls) {
          doc.fillColor('#666666').fontSize(9).font('Helvetica')
            .text(`  â€¢ ${tool.toolName}: ${JSON.stringify(tool.input)}`);
        }
      }

      doc.moveDown(0.5);
      
      // Divider between messages
      doc.strokeColor('#eeeeee').lineWidth(0.5)
        .moveTo(50, doc.y).lineTo(545, doc.y).stroke();
      doc.moveDown(0.5);

      // Check if we need a new page
      if (doc.y > 750) {
        doc.addPage();
      }
    }

    // Footer
    doc.moveDown();
    doc.fillColor('#999999').fontSize(8)
      .text('Generated by Google Maps Agent Chatbot', { align: 'center' });

    doc.end();
  });
}

// Export chat history as DOCX
export async function exportAsDocx(messages: ChatMessage[]): Promise<Buffer> {
  const children: Paragraph[] = [];

  // Title
  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: 'Google Maps Agent Chat Export',
          bold: true,
          size: 32,
        }),
      ],
      heading: HeadingLevel.TITLE,
      alignment: 'center' as any,
    })
  );

  // Metadata
  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `Exported: ${new Date().toLocaleString()}`,
          size: 20,
          color: '666666',
        }),
      ],
      alignment: 'center' as any,
    })
  );

  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `Total Messages: ${messages.length}`,
          size: 20,
          color: '666666',
        }),
      ],
      alignment: 'center' as any,
    })
  );

  children.push(new Paragraph({ children: [] }));

  // Messages
  for (const msg of messages) {
    const timestamp = new Date(msg.timestamp).toLocaleString();
    const isUser = msg.role === 'user';

    // Role header
    children.push(
      new Paragraph({
        children: [
          new TextRun({
            text: msg.role.toUpperCase(),
            bold: true,
            color: isUser ? '2563eb' : '059669',
            size: 24,
          }),
          new TextRun({
            text: `  ${timestamp}`,
            size: 18,
            color: '999999',
          }),
        ],
      })
    );

    // Message content
    children.push(
      new Paragraph({
        children: [
          new TextRun({
            text: msg.content,
            size: 22,
          }),
        ],
      })
    );

    // Tool calls
    if (msg.toolCalls && msg.toolCalls.length > 0) {
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: 'Tool Calls:',
              bold: true,
              color: '8b5cf6',
              size: 20,
            }),
          ],
        })
      );

      for (const tool of msg.toolCalls) {
        children.push(
          new Paragraph({
            children: [
              new TextRun({
                text: `  â€¢ ${tool.toolName}: ${JSON.stringify(tool.input)}`,
                size: 18,
                color: '666666',
              }),
            ],
          })
        );
      }
    }

    // Spacing between messages
    children.push(new Paragraph({ children: [] }));
  }

  const doc = new Document({
    sections: [
      {
        properties: {},
        children,
      },
    ],
  });

  return await Packer.toBuffer(doc);
}
